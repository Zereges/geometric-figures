#!/usr/bin/perl

# Geometric Figures  Copyright (C) 2015  Lukáš Ondráček <ondracek.lukas@gmail.com>, see README file

# scriptWrappers.pl scans all (resp. given) header files and creates necessary wrapper functions

# To make function accessible from python,
# add comment [SCRIPT_NAME: funcName] at the line of function declaration in a header file.
# Function can be then accessed using gf.funcName().

use warnings;
use strict;
use v5.10;

my $print_headers=0;
my @files;
for (@ARGV) {
	if ($_ eq "--headers"){
		$print_headers=1;
		next;
	}
	push @files, $_;
}
@ARGV=@files;

sub getType($) {
	local $_=shift;

	my $rx_ignore      = qr/\s*(?:\b(?:extern|const)\b\s*)*/;
	my $rx_type        = qr/(?:char\*|int|float|void)/;
	my %format_mapping = ("char*" => "s", int => "i", float => "f", void => ""); # !! add color, ...

	s/\s*\*/\*/g;

	my ($type) = /^$rx_ignore($rx_type)$rx_ignore$/;
	return () unless defined $type;

	my $format = $format_mapping{$type};
	return () unless defined $format;

	return ($type, $format);
}

my ($fc,$fh);
unless ($print_headers) {
	open $fc, ">", "scriptWrappers.c.tmp" or die "Cannot open scriptWrappers.c.tmp";
	open $fh, ">", "scriptWrappers.h.tmp" or die "Cannot open scriptWrappers.c.tmp";
	my $str= <<EOF;
// Generated by 'scriptWrappers.pl'
// vim: filetype=c
EOF
	say $fc $str;
	say $fh $str;
}


my $lastFile="";
my $comment=0;
my $last=0;
my $wrappersList="";
main:
while (<>) {
	say STDERR "Skipping: $last" if $last;
	$last=0;

	chomp;
	/\[SCRIPT_NAME:\s*([\w\d_]+)\s*\]/;
	my $name=$1;

	$comment=0 if $comment && s=^.*?\*/==;
	s=/\*.*?\*/|//.*$==g;
	next if $comment;
	$comment = s=/\*.*$==;

	next unless $name;

	$last = $_;

	my ($retType, $funcName, $params) = /\s*(.*?)\s*\b([\w\d_]+)\s*\((.*)\)/;
	next unless $retType && $funcName && defined $params;

	my @retType = getType $retType;
	next unless @retType;

	my @params=();
	if ($params !~ /^\s*(?:void\s*)?$/) {
		@params=split /\,\s*/, $params;
		@params=map [/(.*)\s*\b([\w\d_]+)/], @params;
		for (@params) {
			next main unless @$_==2;
		}

		@params=map [getType $_->[0], $_->[1]], @params;

		for (@params) {
			next main unless @$_==3;
		}
	}

	$last=0;

	if ($print_headers) {
		say $_, " as $name";
	} else {
		if ($lastFile ne $ARGV) {
			say $fc "\n#include \"$ARGV\"\n";
			$lastFile=$ARGV;
		}
		my $localVarsDecl         = join "", map "\n\t$_->[0] $_->[2];", @params;
		   $localVarsDecl        .= "\n\t$retType[0] ret;" if $retType[1];
		my $commaLocalVarsPtrList = join "",   map ", &$_->[2]", @params;
		my $localVarsList         = join ", ", map "$_->[2]", @params;
		my $format                = join "",   map $_->[1], @params;
		my $retVarEq              = ($retType[1] ? "ret=" : "");
		my $commaRetVar           = ($retType[1] ? ", ret" : "");


		say $fh <<EOF;
extern PyObject *${funcName}Wrapped(PyObject *self, PyObject *args);
EOF
		say $fc <<EOF;
extern PyObject *${funcName}Wrapped(PyObject *self, PyObject *args) {${localVarsDecl}
	if(!PyArg_ParseTuple(args, "$format"$commaLocalVarsPtrList))
		return NULL;
	$retVarEq$funcName($localVarsList);
	if (PyErr_Occurred())
		return NULL;
	return Py_BuildValue("$retType[1]"$commaRetVar);
}
EOF
		$wrappersList.="\t{\"$name\", ${funcName}Wrapped, METH_VARARGS, \"\"},\n";
	}
	

	#say $name;
	#say join " -- ", @retType;
	#say $funcName;
	#say (join " -- ", @$_) for @params;
	#say ""
	

}

say STDERR "Skipping: $last" if $last;

say $fh <<EOF;
static PyMethodDef scriptWrappersList[] = {
$wrappersList	{NULL, NULL, 0, NULL}
};
EOF

unless ($print_headers) {
	close $fc;
	close $fh;
}
